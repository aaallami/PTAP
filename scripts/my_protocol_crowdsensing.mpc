from Compiler import library as lib
import random
# =============================================================================
# BENCHMARKING & PROTOCOL CONFIGURATION
# =============================================================================
# NOTE: This code is intended for testing the logic of the protocols.
# To reproduce paper scalability, use the experimental setup in the paper.
# -----------------------------------------------------------------------------
from Compiler import library as lib
import random

# =============================================================================
# CONFIGURATION
# =============================================================================
NUM_USERS = 10000 
TEST_NUM = 100    
NUM_TASKS = 500

registered_ids = Array(NUM_USERS, sint)
registered_keys = Array(NUM_USERS, sint)
task_details = Array(NUM_TASKS, sint) # Added for Publish
users = Array(NUM_USERS, sint) 
keys_array = sint.Array(NUM_USERS)
# =============================================================================
# FUNCTIONS
# =============================================================================

def Register():
    # 1. Generate 40-bit keys and store them in the KEY array
    keys = [random.getrandbits(40) for _ in range(NUM_USERS)]
    registered_keys.assign(sint(keys))
    
    # 2. RID = Real ID + Key
    registered_ids.assign(regint.inc(NUM_USERS) + registered_keys.get_vector())
    
    # 3. Send shares to Worker
    registered_ids.reveal_to(0)

def Verify(_id):
    # This vectorized operation handles the 750k subtractions in one go
    # It is the most efficient way to 'search' in MPC
    values[:] = (registered_ids - _id).reveal()

    # 'found' acts as a flag: 0 = False, 1 = True
    # regint is a local CPU-side register, very fast for logic checks
    found = regint(0)

    # Parallelized loop optimized for multi-core (Xeon vCPUs)
    @for_range_opt(NUM_USERS)
    def _(i):
        # We check the revealed 'values' array for a zero
        @if_(values[i] == 0)
        def _():
            found.write(1)

    # Return the flag (0 or 1) to the main benchmarking loop
    return found

## PreValidate: Ownership Protocol (Lines 1-2)
def PreValidate(_id):
    # USE THIS: Generates a 40-bit secret challenge at runtime
    # This ensures the platform doesn't "know" the challenge in advance
    challenge = sint(random.getrandbits(40))
    
    # We reveal (_id + challenge) to simulate sending the 'v' value to the worker
    # The 'challenge' itself remains a secret share on the servers for Validation
    v = (_id + challenge).reveal()
    
    return v, challenge

## Validate: Ownership Protocol (Lines 4-6)
# Note: 'v' is the worker's response (sint), 
# 'key' is the registered_key[i] (sint), 
# 'challenge' is the secret challenge from PreValidate (sint).
def Validate(v, key, challenge):
    # Compute the difference in the encrypted/shared domain
    # [challenge_prime] = [v] - ([key] + [challenge])
    challenge_prime = v - (key + challenge)
    
    # Reveal the result: 0 means the worker successfully proved ownership
    result = challenge_prime.reveal()
    
    # Returns True if they match, False otherwise
    return (result == 0)

def Trace(_id):
    # Vectorized subtraction to find the match across the 750k database
    # This reveals the distance; 0 means we found the correct entry
    values[:] = (registered_ids - _id).reveal()

    # We use a 'cint' to hold the recovered ID. 
    # We initialize it with -1 to indicate 'not found'
    traced_id = regint(-1)

    @for_range_opt(NUM_USERS)
    def _(i):
        # Check the revealed value
        @if_(values[i] == 0)
        def _():
            # Recover the original ID: ID = (ID + Key) - Key
            # We reveal the result because Trace is an intentional 
            # de-anonymization step by the authorities.
            recovered = (registered_ids[i] - registered_keys[i]).reveal()
            traced_id.write(recovered)

    return traced_id

def Publish(task_id, description_val):
    """
    Simulates publishing a task. In PTAP, this usually involves 
    encrypting or secret-sharing task metadata.
    """
    # Store the secret task description (e.g., a hashed location or ID)
    task_details[task_id] = sint(description_val)
    # In a real system, this would involve broadcasting to workers
    return True 

# =============================================================================
# MAIN EXECUTION / BENCHMARKING SEQUENCE
# =============================================================================

print_ln("Starting PTAP Logic Test... (Workers: %s | Tasks: %s | Test Ops: %s)", 
         NUM_USERS, NUM_TASKS, TEST_NUM)

# 1. REGISTER
print_ln("Timer 1: Registering...")
lib.start_timer(1)
Register()
lib.stop_timer(1)

# =============================================================================
# FINAL BENCHMARK SUMMARY
# =============================================================================
print_ln("\n========================================================")
print_ln("PTAP BENCHMARK SUMMARY")
print_ln("========================================================")
print_ln("Configuration: Workers=%s, Tasks=%s, Test_Ops=%s", 
         NUM_USERS, NUM_TASKS, TEST_NUM)
print_ln("--------------------------------------------------------")
print_ln("Time1 (Register): %s s", lib.get_timer(1))
print_ln("Time5 (Publish):  %s s", lib.get_timer(5))
print_ln("Time2 (Verify):   %s s", lib.get_timer(2))
print_ln("Time3 (Validate): %s s", lib.get_timer(3))
print_ln("Time4 (Trace):    %s s", lib.get_timer(4))
print_ln("========================================================\n")
