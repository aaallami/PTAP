from Compiler import library as lib

# =============================================================================
# BENCHMARKING & PROTOCOL CONFIGURATION
# =============================================================================
# NOTE: This code is intended for testing the logic of the protocols.
# To reproduce paper scalability, use the experimental setup in the paper.
# -----------------------------------------------------------------------------
NUM_USERS = 750000 
TEST_NUM = 10000
n_tasks = 500  # Added missing variable

# Initialize Arrays before function definitions
registered_ids = Array(NUM_USERS, sint)
registered_keys = Array(NUM_USERS, sint)
task_details = Array(n_tasks, sint)
users = Array(NUM_USERS, sint) # Fix: Don't use users = []
values = Array(NUM_USERS, cint)
# =============================================================================

def Register(_id, i):
    # Generates a 40-bit secret-shared random integer
    # This provides the information-theoretic security described in the paper
    key = sint.get_random_int(40)
    
    # Blinding the ID with the secret key: [val] = [id] + [key]
    val = _id + key

    # Store shares on the servers
    registered_ids[i] = val
    registered_keys[i] = key

    # Send the blinded ID to the worker
    return val.reveal()

def Verify(_id):
    # This vectorized operation handles the 750k subtractions in one go
    # It is the most efficient way to 'search' in MPC
    values[:] = (registered_ids - _id).reveal()

    # 'found' acts as a flag: 0 = False, 1 = True
    # regint is a local CPU-side register, very fast for logic checks
    found = regint(0)

    # Parallelized loop optimized for multi-core (Xeon vCPUs)
    @for_range_opt(NUM_USERS)
    def _(i):
        # We check the revealed 'values' array for a zero
        @if_(values[i] == 0)
        def _():
            found.write(1)

    # Return the flag (0 or 1) to the main benchmarking loop
    return found

##Prevalidate is Ownership Protocol Lines 1-2
def PreValidate(_id):
    challenge = sint(rand.randint(0, 1000))
    #not sure best way to keep challenge with server
    return (_id + challenge).reveal(), challenge #using as sending to user not sure if better way to do this in mpsdz

##Validate is Ownership Protocol Lines 4-6 Note that line 3 is done below with v' = Prevalidate - user_id
def Validate(v, key, challenge):
    challenge_prime = v - (key + challenge)
    return (challenge_prime.reveal() == 0)

def Trace(_id):
    global registered_keys
    global registered_ids
    global values

    idx = -1
    values[:] = (registered_ids - _id).reveal()

    @for_range(len(registered_ids))
    def _(i):
        @if_e(values[i] == 0)
        def _(): 
            return (registered_ids[i] - registered_keys[i]).reveal()
        @else_
        def _():
            pass
        
    return cint(-1)

def Publish(task_id, description_val):
    """
    Simulates publishing a task. In PTAP, this usually involves 
    encrypting or secret-sharing task metadata.
    """
    # Store the secret task description (e.g., a hashed location or ID)
    task_details[task_id] = sint(description_val)
    # In a real system, this would involve broadcasting to workers
    return True 

print_ln("Starting... (Num Users %s : Test Num %s)", NUM_USERS, TEST_NUM)

print_ln("Registering Users...")
lib.start_timer(1)

@for_range(NUM_USERS)
def _(i):
    users[i] = Register(sint(i), i)

lib.stop_timer(1)

print_ln("Verification Test...")

lib.start_timer(2)

@for_range(TEST_NUM)
def _(i):
    Verify(users[i])

lib.stop_timer(2)

print_ln("Validation Test...")

lib.start_timer(3)

#Ownership protocall consists of the prevalidate and validate functions

@for_range(TEST_NUM)
def _(i):
    v, challenge = PreValidate(users[i])
    v_prime = sint(v - i)
    Validate(v_prime, registered_keys[i], challenge)

lib.stop_timer(3)

lib.start_timer(4)

@for_range(TEST_NUM)
def _(i):
    Trace(users[i])

lib.stop_timer(4)

print_ln("Publishing Tasks...")
lib.start_timer(5)

@for_range(n_tasks)
def _(i):
    # Simulating publishing tasks with unique identifiers
    Publish(i, i + 5000) 

lib.stop_timer(5)
print_ln("\nNum Users = %s\nTime = Total\nTime1 = Register\nTime2 = Verify\nTime3 = Validate\nTime4 = Trace\n", NUM_USERS)
