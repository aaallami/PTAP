from Compiler import library as lib
import random

# =============================================================================
# BENCHMARKING & PROTOCOL CONFIGURATION
# =============================================================================
# Configuration for high-scale crowdsensing simulation.
# -----------------------------------------------------------------------------
NUM_USERS = 10000
TEST_NUM = 10000
NUM_TASKS = 500

registered_ids = Array(NUM_USERS, sint)
registered_keys = Array(NUM_USERS, sint)
task_details = Array(NUM_TASKS, sint)
users = Array(NUM_USERS, sint) 
values = Array(NUM_USERS, cint)

# =============================================================================
# FUNCTIONS
# =============================================================================

def Register(_id, i):
    # Generates 40-bit key and combines with ID
    key = sint(random.getrandbits(40))
    val = _id + key

    registered_ids[i] = val
    registered_keys[i] = key

    # Return revealed share to simulate worker RID distribution
    return val.reveal()

def Verify(_id):
    # Vectorized subtraction and reveal
    values.assign((registered_ids.get_vector() - _id).reveal())

    found = MemValue(regint(0))
    @for_range_opt(NUM_USERS)
    def _(i):
        is_match = (values[i] == 0)
        @if_(is_match)
        def _():
            found.write(1)
    return found.read()

def PreValidate(_id):
    challenge = sint.get_random_int(40)
    v = (_id + challenge).reveal()
    return v, challenge

def Validate(v, key, challenge):
    # challenge_prime = [v] - ([key] + [challenge])
    challenge_prime = v - (key + challenge)
    result = challenge_prime.reveal()
    return (result == 0)

def Trace(_id):
    values.assign((registered_ids.get_vector() - _id).reveal())
    traced_id = MemValue(regint(-1))

    @for_range_opt(NUM_USERS)
    def _(i):
        is_match = (values[i] == 0)
        @if_(is_match)
        def _():
            # Recover ID: (ID + Key) - Key
            recovered = (registered_ids[i] - registered_keys[i]).reveal()
            traced_id.write(recovered)
    return traced_id.read()

def Publish(task_id, description_val):
    # Simulates publishing task metadata to the platform
    task_details[task_id] = sint(description_val)
    return True 

# =============================================================================
# MAIN EXECUTION / BENCHMARKING SEQUENCE
# =============================================================================

print_ln("Starting PTAP Logic Test... (Workers: %d | Test Ops: %d)" % (NUM_USERS, TEST_NUM))

# 1. REGISTER
print_ln("Timer 1: Registering...")
lib.start_timer(1)
@for_range(NUM_USERS)
def _(i):
    users[i] = Register(sint(i), i)
lib.stop_timer(1)

# 2. PUBLISH
print_ln("Timer 5: Publishing Tasks...")
lib.start_timer(5)
@for_range(NUM_TASKS)
def _(i):
    Publish(i, 12345)
lib.stop_timer(5)

# 3. VERIFY
print_ln("Timer 2: Verifying...")
lib.start_timer(2)
@for_range(TEST_NUM)
def _(i):
    Verify(users[i])
lib.stop_timer(2)

# 4. VALIDATE
print_ln("Timer 3: Validating Ownership...")
lib.start_timer(3)
@for_range(TEST_NUM)
def _(i):
    v, challenge = PreValidate(users[i])
    v_prime = sint(v - i)
    Validate(v_prime, registered_keys[i], challenge)
lib.stop_timer(3)

# 5. TRACE
print_ln("Timer 4: Tracing...")
lib.start_timer(4)
@for_range(TEST_NUM)
def _(i):
    Trace(users[i])
lib.stop_timer(4)

# =============================================================================
# FINAL BENCHMARK SUMMARY
# =============================================================================
print_ln("========================================================")
print_ln("PTAP BENCHMARK SUMMARY")
print_ln("========================================================")
print_ln("Configuration: Workers=%d, Test_Ops=%d" % (NUM_USERS, TEST_NUM))
print_ln("--------------------------------------------------------")
print_ln("Protocol completed successfully.")
print_ln("Summary of rounds and timing will follow below.")
print_ln("========================================================")
