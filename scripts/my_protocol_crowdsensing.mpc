from Compiler import library as lib

# =============================================================================
# BENCHMARKING & PROTOCOL CONFIGURATION
# =============================================================================
# NOTE: This code is intended for testing the logic of the protocols.
# To reproduce paper scalability, use the experimental setup in the paper.
# -----------------------------------------------------------------------------
NUM_USERS = 750000 
TEST_NUM = 10000
NUM_TASKS = 500 

# Initialize Arrays before function definitions
registered_ids = Array(NUM_USERS, sint)
registered_keys = Array(NUM_USERS, sint)
task_details = Array(NUM_TASKS, sint)
users = Array(NUM_USERS, sint) # Fix: Don't use users = []
values = Array(NUM_USERS, cint)
# =============================================================================

def Register(_id, i):
    # Generates a 40-bit secret-shared random integer
    # This provides the information-theoretic security described in the paper
    key = sint.get_random_int(40)
    
    # Blinding the ID with the secret key: [val] = [id] + [key]
    val = _id + key

    # Store shares on the servers
    registered_ids[i] = val
    registered_keys[i] = key

    # Send the blinded ID to the worker
    return val.reveal()

def Verify(_id):
    # This vectorized operation handles the 750k subtractions in one go
    # It is the most efficient way to 'search' in MPC
    values[:] = (registered_ids - _id).reveal()

    # 'found' acts as a flag: 0 = False, 1 = True
    # regint is a local CPU-side register, very fast for logic checks
    found = regint(0)

    # Parallelized loop optimized for multi-core (Xeon vCPUs)
    @for_range_opt(NUM_USERS)
    def _(i):
        # We check the revealed 'values' array for a zero
        @if_(values[i] == 0)
        def _():
            found.write(1)

    # Return the flag (0 or 1) to the main benchmarking loop
    return found

## PreValidate: Ownership Protocol (Lines 1-2)
def PreValidate(_id):
    # USE THIS: Generates a 40-bit secret challenge at runtime
    # This ensures the platform doesn't "know" the challenge in advance
    challenge = sint.get_random_int(40)
    
    # We reveal (_id + challenge) to simulate sending the 'v' value to the worker
    # The 'challenge' itself remains a secret share on the servers for Validation
    v = (_id + challenge).reveal()
    
    return v, challenge

## Validate: Ownership Protocol (Lines 4-6)
# Note: 'v' is the worker's response (sint), 
# 'key' is the registered_key[i] (sint), 
# 'challenge' is the secret challenge from PreValidate (sint).
def Validate(v, key, challenge):
    # Compute the difference in the encrypted/shared domain
    # [challenge_prime] = [v] - ([key] + [challenge])
    challenge_prime = v - (key + challenge)
    
    # Reveal the result: 0 means the worker successfully proved ownership
    result = challenge_prime.reveal()
    
    # Returns True if they match, False otherwise
    return (result == 0)

def Trace(_id):
    # Vectorized subtraction to find the match across the 750k database
    # This reveals the distance; 0 means we found the correct entry
    values[:] = (registered_ids - _id).reveal()

    # We use a 'cint' to hold the recovered ID. 
    # We initialize it with -1 to indicate 'not found'
    traced_id = regint(-1)

    @for_range_opt(NUM_USERS)
    def _(i):
        # Check the revealed value
        @if_(values[i] == 0)
        def _():
            # Recover the original ID: ID = (ID + Key) - Key
            # We reveal the result because Trace is an intentional 
            # de-anonymization step by the authorities.
            recovered = (registered_ids[i] - registered_keys[i]).reveal()
            traced_id.write(recovered)

    return traced_id

def Publish(task_id, description_val):
    """
    Simulates publishing a task. In PTAP, this usually involves 
    encrypting or secret-sharing task metadata.
    """
    # Store the secret task description (e.g., a hashed location or ID)
    task_details[task_id] = sint(description_val)
    # In a real system, this would involve broadcasting to workers
    return True 

# =============================================================================
# MAIN EXECUTION / BENCHMARKING SEQUENCE
# =============================================================================

print_ln("Starting PTAP Logic Test... (Workers: %s | Tasks: %s | Test Ops: %s)", 
         NUM_USERS, NUM_TASKS, TEST_NUM)

# 1. REGISTER: Populates the system with workers
print_ln("Registering Workers...")
lib.start_timer(1)
@for_range_opt(NUM_USERS)
def _(i):
    # Register returns revealed (ID + Key)
    users[i] = Register(sint(i), i)
lib.stop_timer(1)

# 2. PUBLISH: Sets up the sensing tasks
print_ln("Publishing Tasks...")
lib.start_timer(5)
@for_range_opt(NUM_TASKS)
def _(i):
    # Publish task metadata securely
    Publish(i, i + 5000) 
lib.stop_timer(5)

# 3. VERIFICATION: Benchmark the search/verify latency
print_ln("Running Verification Tests...")
lib.start_timer(2)
@for_range_opt(TEST_NUM)
def _(i):
    Verify(users[i])
lib.stop_timer(2)

# 4. VALIDATION: Benchmark the Ownership Protocol (PreValidate + Validate)
print_ln("Running Validation (Ownership) Tests...")
lib.start_timer(3)
@for_range_opt(TEST_NUM)
def _(i):
    # Server generates challenge
    v_blinded, challenge = PreValidate(users[i])
    # Worker computes response (v_prime = v_blinded - id)
    # We simulate worker computation here
    v_prime = sint(v_blinded - i) 
    # Server performs final validation
    Validate(v_prime, registered_keys[i], challenge)
lib.stop_timer(3)

# 5. TRACE: Benchmark the security/de-anonymization latency
print_ln("Running Trace Tests...")
lib.start_timer(4)
@for_range_opt(TEST_NUM)
def _(i):
    Trace(users[i])
lib.stop_timer(4)

# =============================================================================
# FINAL BENCHMARK SUMMARY
# =============================================================================
print_ln("\n========================================================")
print_ln("PTAP BENCHMARK SUMMARY")
print_ln("========================================================")
print_ln("Configuration: Workers=%s, Tasks=%s, Test_Ops=%s", 
         NUM_USERS, NUM_TASKS, TEST_NUM)
print_ln("--------------------------------------------------------")
print_ln("Time1 (Register): %s s", lib.get_timer(1))
print_ln("Time5 (Publish):  %s s", lib.get_timer(5))
print_ln("Time2 (Verify):   %s s", lib.get_timer(2))
print_ln("Time3 (Validate): %s s", lib.get_timer(3))
print_ln("Time4 (Trace):    %s s", lib.get_timer(4))
print_ln("========================================================\n")
