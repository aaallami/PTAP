from Compiler import library as lib
import random

# =============================================================================
# BENCHMARKING & PROTOCOL CONFIGURATION
# =============================================================================
# NOTE: Optimized for large-scale token processing.
# -----------------------------------------------------------------------------
NUM_TOKENS = 1000000
TEST_OPS = 1000

# Memory Allocation
tokens = sint.Array(NUM_TOKENS)
mask = sint.Array(NUM_TOKENS)
flag = sint.Array(NUM_TOKENS)
delta = cint.Array(NUM_TOKENS)

# =============================================================================
# FUNCTIONS
# =============================================================================

def Token_Issuance():
    """
    Simulates the generation and initial distribution of secret tokens.
    """
    # Initialize all flags to active (1)
    flag.assign_all(sint(1))

    @for_range_opt(NUM_TOKENS)
    def _(i):
        # Generate 32-bit random secret shares
        tokens[i] = sint.get_random_int(32)
        
        # We reveal for simulation/timing purposes as per the original logic
        tokens[i].reveal()

def Token_Reimbursement(tid):
    """
    Searches and invalidates a token while maintaining privacy-preserving counts.
    """
    # 1. Vectorized distance calculation
    # Efficiently find the matching token in the database
    delta[:] = (tokens - tid).reveal()

    # 2. Local counter for valid tokens remaining
    # Use regint for high-speed local logic
    valid_count = regint(0)
    
    @for_range_opt(NUM_TOKENS)
    def _(i):
        # If delta is 0, we found the token to be reimbursed
        @if_e(delta[i] == 0)
        def _():
            mask[i] = sint(0)
        @else_
        def _():
            mask[i] = sint(1)
            # Increment the local counter using regint.inc() logic or write
            valid_count.write(valid_count + 1)
    
    # 3. Security Check: If count is incorrect, invalidate the batch
    @if_e(valid_count == (NUM_TOKENS - 1))
    def _():
        pass
    @else_
    def _():
        mask.assign_all(sint(1))

    # 4. Update the global state
    flag[:] = flag.get_vector() * mask.get_vector()

# =============================================================================
# MAIN EXECUTION / BENCHMARKING SEQUENCE
# =============================================================================

print_ln("Starting Token Logic Test... (Tokens: %s | Test Ops: %s)", NUM_TOKENS, TEST_OPS)

# 1. ISSUANCE
print_ln("Timer 1: Issuing Tokens...")
lib.start_timer(1)
Token_Issuance()
lib.stop_timer(1)

# 2. REIMBURSEMENT
print_ln("Timer 2: Processing Reimbursements...")
lib.start_timer(2)
@for_range(TEST_OPS)
def _(i):
    # We pass the secret token as a challenge
    Token_Reimbursement(tokens[i])   
lib.stop_timer(2)

# =============================================================================
# FINAL BENCHMARK SUMMARY
# =============================================================================
print_ln("\n========================================================")
print_ln("TOKEN PROTOCOL BENCHMARK SUMMARY")
print_ln("========================================================")
print_ln("Configuration: Tokens=%s, Test_Ops=%s", NUM_TOKENS, TEST_OPS)
print_ln("--------------------------------------------------------")
print_ln("Time1 (Issuance):      %s s", lib.get_timer(1))
print_ln("Time2 (Reimbursement): %s s", lib.get_timer(2))
print_ln("========================================================\n")
